#+title: Cutting and Storing Text
#+author: Marian Domanski
#+date: <2025-08-10 Sun 20:55>
#+startup: overview

* DONE Storing Text in a List
CLOSED: [2025-08-10 Sun 21:27]

#+begin_src elisp
  (cons "another piece"
        '("a piece of text" "previous piece"))
#+end_src

#+RESULTS:
| another piece | a piece of text | previous piece |

#+begin_src elisp
  (car (nthcdr 1 '("another piece"
                   "a piece of text"
                   "previous piece")))
#+end_src

#+RESULTS:
: a piece of text

* DONE 8.1 ‘zap-to-char’ [5/5]

** The Complete ‘zap-to-char’ Implementation

#+begin_src elisp
  (defun zap-to-char (arg char)
    "Kill up to and including ARG'th occurrence of CHAR.
  Case is ignored if `case-fold-search' is non-nil in the current buffer.
  Goes backward if ARG is negative; error if CHAR not found."
    (interactive "p\ncZap to char: ")
    (if (char-table-p translation-table-for-input)
        (setq char (or (aref translation-table-for-input char) char)))
    (kill-region (point) (progn
                           (search-forward (char-to-string char)
                                           nil nil arg)
                           (point))))
#+end_src

** DONE 8.1.1 The ‘interactive’ Expression
CLOSED: [2025-08-16 Sat 21:58]

** DONE 8.1.2 The Body of ‘zap-to-char’
CLOSED: [2025-08-16 Sat 22:01]

** DONE 8.1.3 The ‘search-forward’ Function
CLOSED: [2025-08-17 Sun 09:39]

** DONE 8.1.4 The ‘progn’ Special Form
CLOSED: [2025-08-17 Sun 09:59]

** DONE 8.1.5 Summing up ‘zap-to-char’
CLOSED: [2025-08-17 Sun 10:08]

* DONE 8.2 ‘kill-region’ [2/2]

** The Complete ‘kill-region’ Definition

#+begin_src elisp
  (defun kill-region (beg end)
    "Kill (\"cut\") text between point and mark.
  This deletes the text from the buffer and saves it in the kill ring.
  The command \\[yank] can retrieve it from there. ... "

    ;; • Since order matters, pass point first.
    (interactive (list (point) (mark)))
    ;; • And tell us if we cannot cut the text.
    ;; 'unless' is an 'if' without a then-part.
    (unless (and beg end)
      (error "The mark is not set now, so there is no region"))

    ;; • 'condition-case' takes three arguments.
    ;;    If the first argument is nil, as it is here,
    ;;    information about the error signal is not
    ;;    stored for use by another function.
    (condition-case nil

        ;; • The second argument to 'condition-case' tells the
        ;;    Lisp interpreter what to do when all goes well.

        ;;    It starts with a 'let' function that extracts the string
        ;;    and tests whether it exists.  If so (that is what the
        ;;    'when' checks), it calls an 'if' function that determines
        ;;    whether the previous command was another call to
        ;;    'kill-region'; if it was, then the new text is appended to
        ;;    the previous text; if not, then a different function,
        ;;    'kill-new', is called.

        ;;    The 'kill-append' function concatenates the new string and
        ;;    the old.  The 'kill-new' function inserts text into a new
        ;;    item in the kill ring.

        ;;    'when' is an 'if' without an else-part.  The second 'when'
        ;;    again checks whether the current string exists; in
        ;;    addition, it checks whether the previous command was
        ;;    another call to 'kill-region'.  If one or the other
        ;;    condition is true, then it sets the current command to
        ;;    be 'kill-region'.
        (let ((string (filter-buffer-substring beg end t)))
          (when string                    ;STRING is nil if BEG = END
            ;; Add that string to the kill ring, one way or another.
            (if (eq last-command 'kill-region)
                ;;    − 'yank-handler' is an optional argument to
                ;;    'kill-region' that tells the 'kill-append' and
                ;;    'kill-new' functions how deal with properties
                ;;    added to the text, such as 'bold' or 'italics'.
                (kill-append string (< end beg) yank-handler)
              (kill-new string nil yank-handler)))
          (when (or string (eq last-command 'kill-region))
            (setq this-command 'kill-region))
          nil)

      ;;  • The third argument to 'condition-case' tells the interpreter
      ;;    what to do with an error.
      ;;    The third argument has a conditions part and a body part.
      ;;    If the conditions are met (in this case,
      ;;             if text or buffer are read-only)
      ;;    then the body is executed.
      ;;    The first part of the third argument is the following:
      ((buffer-read-only text-read-only) ;; the if-part
       ;; ...  the then-part
       (copy-region-as-kill beg end)
       ;;    Next, also as part of the then-part, set this-command, so
       ;;    it will be set in an error
       (setq this-command 'kill-region)
       ;;    Finally, in the then-part, send a message if you may copy
       ;;    the text to the kill ring without signaling an error, but
       ;;    don't if you may not.
       (if kill-read-only-ok
           (progn (message "Read only text copied to kill ring") nil)
         (barf-if-buffer-read-only)
         ;; If the buffer isn't read-only, the text is.
         (signal 'text-read-only (list (current-buffer))))))))
#+end_src

** DONE 8.2.1 ‘condition-case’
CLOSED: [2025-08-18 Mon 20:40]

** DONE 8.2.2 Lisp macro
CLOSED: [2025-08-18 Mon 20:42]

* TODO 8.3 ‘copy-region-as-kill’ [0/1]

** The complete ‘copy-region-as-kill’ function definition

#+begin_src elisp
  (defun copy-region-as-kill (beg end)
    "Save the region as if killed, but don't kill it.
  In Transient Mark mode, deactivate the mark.
  If `interprogram-cut-function' is non-nil, also save the text for a window
  system cut and paste."
    (interactive "r")
    (if (eq last-command 'kill-region)
        (kill-append (filter-buffer-substring beg end) (< end beg))
      (kill-new (filter-buffer-substring beg end)))
    (if transient-mark-mode
        (setq deactivate-mark t))
    nil))
#+end_src

** TODO 8.3.1 The Body of ‘copy-region-as-kill’

** ‘last-command’ and ‘this-command’

** The ‘kill-append’ function

** The ‘kill-new’ function

* TODO 8.4 Digression into C

* TODO 8.5 Initializing a Variable with ‘defvar’ [0/1]

** Seeing the Current Value of a Variable

** TODO 8.5.1 ‘defvar’ and an asterisk

* TODO 8.6 Review

* TODO 8.7 Searching Exercises [0/2]

** TODO Write an interactive function that searches for a string.

** TODO Write a function that prints the third element of the kill ring in the echo area...
